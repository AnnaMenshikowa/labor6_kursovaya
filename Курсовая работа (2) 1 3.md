Замечания руководителя

<a name="_toc73222536"></a>Содержание

[ВВЕДЕНИЕ	2](#_toc458224428)

[1 Анализ предметной области	3](#_toc477831804)

[1.1	Особенности функционирования мобильных приложений в различных операционных системах	4](#_toc1177012254)

[1.2 Инструментальные средства разработки мобильных приложений	8](#_toc70003488)

[1.3. Цели и задачи курсового проекта	13](#_toc472981381)

[2. Проектирование мобильного приложения	14](#_toc1477070646)

[2.1. Обоснование выбора средства разработки	15](#_toc2097463298)

[2.2. Проектирование приложения	16](#_toc61011757)

[2.3. Структура мобильного приложения	18](#_toc1923979928)

[3.2. Работа приложения	20](#_toc1286155211)

[СПИСОК ЛИТЕРАТУРЫ	28](#_toc1312793178)

[ПРИЛОЖЕНИЕ А	29](#_toc718956430)




# <a name="_toc458224428"></a>ВВЕДЕНИЕ
Ведение заметок является весьма важной задачей для многих современных и активных людей, однако в современном мире носить с собой толстую записную книжку не всегда удобно. При большом количестве записей, поиск необходимой заметки в бумажной записной книжке может отнять много времени, также количество страниц в записной книжке ограничено, а при приобретении новой носить сразу несколько книжек не очень практично.
Текущий уровень развития сферы IT позволяет пользователям иметь такую записную книжку практически в любом из современных электронных устройств. Электронная записная книжка не занимает места, количество заметок практически ничем не ограничено, а поиск необходимой заметки занимает считанные секунды.

Проект состоит из теоретической и практической частей. В теоретической части приведен анализ предметной области, в рамках которого будут рассмотрены особенности предметной области, сформулирована цель проекта, определен круг запросов и задач. 

В практической части детально описываются этапы написания программного кода на языке программирования Java и разработка удобного интерфейса.


# <a name="_toc477831804"></a>1 Анализ предметной области 

1. ## <a name="_toc1177012254"></a>Особенности функционирования мобильных приложений в различных операционных системах

Дизайн мобильных ОС прошел эволюцию от ОС для настольных ПК через встраиваемые ОС до тех продуктов, которые мы видим в смартфонах сейчас. В течение этого процесса архитектура ОС менялась от сложной к простой и остановилась где-то на середине. Сама же эволюция приводилась в движение технологическими достижениями в аппаратной и программной области, а также в интернет сервисах.

В недавнем прошлом модель использования мобильных устройств была весьма простой. Пользователь запускал приложения для управления данными или оффлайновых игр, иногда загружал статические веб-странички или пользовался почтой. Сейчас ситуация поменялась кардинальным образом: больше нет «предустановленных» функций, устройство выступает неким порталом в среду, где множество игроков – сервис провайдеры, независимые разработчики и т.д. – предоставляют огромное количество сервисов (рисунок 1).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.001.png)Рисунок 1 - Модели использования мобильных устройств

С точки зрения моделей потребления, все представители мобильных ОС сегодняшнего дня (такие как Apple iOS, Google Android, Microsoft Windows) имеют больше сходных черт, нежели различий:

Все они имеют документированные SDK с прописанными API, что позволяет разработчикам создавать приложения под эти ОС;

Все они имеют онлайн каталоги приложений, где разработчики публикуют свои приложения и откуда пользователи их скачивают;

В каждой реализована многозадачность и поддержка 3D-графики, широко используются датчики и сенсорные экраны;

Во всех системах большое внимание уделено гладкости и отзывчивости во взаимодействии с пользователем;

Использование интернет далеко ушло от статических страниц, HTML5 становится платформой по умолчанию для Web-приложений;

Все ОС поддерживают мобильные системы платежей;

Все системы сфокусированы на оптимизации энергопотребления.

Общность нынешних мобильных ОС обусловлены глобальностью технологических трендов в аппаратной и программных областях, а также в коммуникациях. Проанализируем теперь популярные ОС (рисунок 2) нового поколения с точки зрения критериев, приведенных выше. Отметим сразу, что в довольной большой степени они конфликтуют друг с другом.

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.002.png)

Рисунок 2 - Мобильные ОС популярность

Android - это операционная система для смартфонов, планшетов, приставок, нетбуков и других устройств. Является собственностью компании Google и признана самой популярной в мире. 22 октября 2008 года Google объявила об открытии онлайн-магазина приложений для ОС Android — Android Market. Количество приложений для Андроид в данном магазине превышает 1,43 млн. Первая версия ОС вышла в свет в 2008 году на смартфоне HTC и с тех пор неустанно обновляется.

Достоинства Android:

- быстрая интеграция с сервисами google
- наличие файловой системы
- абсолютная независимость от аппаратной начинки мобильного устройства
- Android является системой с открытым кодом
- многозадачность
- легкость установки приложений с разных ресурсов
- широкие возможности индивидуализации
- отсутствие ограничений при выборе мобильного оператора
- поддержка Flash-проигрывателя
- обновление через Интернет
- возможность замены/удаления дефолтных приложений

  iOS — операционная система для смартфонов, планшетов и др. устройств, разработанная компанией Apple исключительно для своих устройств.

Пользовательский интерфейс iOS основан на концепции прямого взаимодействия с использованием жестов «мультитач». Элементы управления интерфейсом состоят из ползунков, переключателей и кнопок. Впервые операционная система была представлена в 2007 году.

Достоинства iOS:

- качество поставляемых приложений
- доступность обновлений сразу после выпуска новой версии ОС для всех устройств одновременно
- продолжительная поддержка старых устройств
- разработчики в первую очередь анонсируют свои приложения для iOS
- удобство использования, удобство интерфейса
- акцент на надежность и качество ОС
- семейный доступ для покупок в Appstore
- возможность объединить работу обновленных до последней ОС мобильных устройств

  Windows Phone OS — мобильная операционная система, выпущенная в 2010 году корпорацией Майкрософт. Данную операционку можно легко узнать по своеобразным «живым» плиткам на начальном экране. Не так популярна как 2 предыдущие, но тем не менее имеет ряд своих преимуществ:

Windows — самая распространенная операционная система в мире, и устройства, работающие на ней, легко синхронизируются с компьютером, ноутбуком, планшетом, работающим на Windows

- нет проблем с оперативной памятью
- разнообразие приложений по умолчанию

  Blackberry OS — операционная система для устройств Blackberry на основе QNX, впервые выпущенная в 2009 году. По своей сути ориентирована на бизнес-сегмент, корпоративных пользователей.

Достоинства Blackberry OS:

- технология, которая даёт возможность более эффективно вести дела, оперативно управлять собственным бизнесом и рационально использовать человеческие ресурсы
- возможность работать удалённо, вне офиса, возможность вовремя получить договор, презентацию, отчёт, передать важные документы в работу, не промедлив ни минуты.
- постоянная синхронизация с рабочим местом
- высокая безопасность корпоративных коммуникаций. Даже если аппарат потерялся или разбился, вы не потеряете своей переписки, своих контактов, переписку и другую информацию с утерянного аппарата можно дистанционно удалить.
- позволяет быстро просматривать на аппарате вложения больших размеров практически любых форматов

## <a name="_toc70003488"></a>1.2 Инструментальные средства разработки мобильных приложений

Рассмотрим технологии разработки мобильных приложений, которые могут быть использованы при решении задачи.

Нативные приложения разрабатываются в нативном окружении под определенную операционную систему. Так, для Android в Android Studio используется язык программирования Kotlin или Java, а для iOS в Xcode используется Swift или ObjectiveC [1]. 

В числе преимуществ нативной разработки можно отметить следующее:

- стабильная и быстрая работа приложения;
- максимальный срок жизни приложения;
- приложение более гибкое и масштабируемое, благодаря использованию «родных» инструментов;
- меньше ограничений в архитектуре и функциях;
- интерфейс в точности соответствует платформе.

  Для разработки нативных приложений используются языки программирования:

\1) Kotlin — статически типизированный, объектно-ориентированный язык программирования, работающий поверх Java Virtual Machine и разрабатываемый компанией JetBrains\. Также компилируется в JavaScript и в исполняемый код ряда платформ через инфраструктуру LLVM\. Язык назван в честь острова Котлин в Финском заливе, на котором расположен город Кронштадт [2]\.

Авторы ставили целью создать язык более лаконичный и типобезопасный, чем Java, и более простой, чем Scala. Следствием упрощения по сравнению со Scala стали также более быстрая компиляция и лучшая поддержка языка в IDE. Язык полностью совместим с Java, что позволяет Java-разработчикам постепенно перейти к его использованию; в частности, язык также встраивается Android, что позволяет для существующего android-приложения внедрять новые функции на Kotlin без переписывания приложения целиком.

\2) Java — cтрого типизированный объектно-ориентированный язык программирования общего назначения, разработанный компанией Sun Microsystems\. Разработка ведётся сообществом, организованным через Java Community Process; язык и основные реализующие его технологии распространяются по лицензии GPL\. Ключевой особенностью языка Java является то, что его код сначала транслируется в специальный байт-код, независимый от платформы\. А затем этот байт-код выполняется виртуальной машиной JVM (Java Virtual Machine)\. В этом плане Java отличается от стандартных интерпретируемых языков как PHP или Perl, код которых сразу же выполняется интерпретатором [3]\.

\3) Swift — открытый мультипарадигмальный компилируемый язык программирования общего назначения\. Создан компанией Apple в первую очередь для разработчиков iOS и macOS (в настоящий момент вышел за рамки этих ОС)\. Swift работает с фреймворками Cocoa и Cocoa Touch и совместим с основной кодовой базой Apple, написанной на Objective-C\. Swift задумывался как более лёгкий для чтения и устойчивый к ошибкам программиста язык, нежели предшествовавший ему Objective-C\. Программы на Swift компилируются при помощи LLVM, входящей в интегрированную среду разработки Xcode 6 и выше\. Swift может использовать рантайм Objective-C, что делает возможным использование обоих языков (а также С) в рамках одной программы\.

\4) Objective-C — компилируемый объектно-ориентированный язык программирования, используемый корпорацией Apple, построенный на основе языка Си и парадигм Smalltalk\. В частности, объектная модель построена в стиле Smalltalk — то есть объектам посылаются сообщения\.

При помощи Google Trends выведем статистику популярности рассмотренных языков программирования за последние пять лет (рисунок 3).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.003.png)

Рисунок 3 – Статистика популярности языков программирования

Составим сравнительную таблицу нативных технологий разработки приложений для мобильных устройств (таблица 1).

Таблица 1 — Сравнение нативных технологий

|Характеристика|Kotlin|Java|Swift|Objective-C|
| :- | - | - | - | - |
|Поддержка IOS|-|-|+|+|
|Поддержка Android|+|+|-|-|
|3D Графика|-|-|+|-|
|MVP|-|-|-|-|
|Стабильность|+|+|+|-|
|Виджеты|-|-|+|-|
|WebView|-|+|+|-|
|Поддержка анимации|+|+|+|+|

Исходя из полученных в ходе сравнения результатов, можно сделать вывод, что для поддержки IOS необходимо выбрать Swift и Objective-C,а для поддержки Android-приложений-Kotlin и Java.Для работы с 3D-графикой и виджетами выбираем Swift и Objective-C.Также, стоит отметить, что все нативные технологии имеют поддержку анимации.

Гибридные приложения — симбиоз нативных приложений и веб-приложений. Так же, как и нативные приложения, их можно загрузить в магазине приложений, а сами гибридные приложения могут использовать множество функций устройства, на котором установлены. Так же, как и веб-приложения, основой их платформы является HTML5. Они обрабатываются через браузер, который встроен в само приложение. Основной плюс разработки гибридного приложения: оно сразу работает под обеими платформами, да и в целом под любыми другими. Минусом гибридных приложений является то, что они работают с задержкой и определенными ограничениями, и, как правило, имеет менее дружественный интерфейс и больше багов [1].

` `Для разработки гибридных приложений используются кроссплатформенные фреймворки:

\1) React Native — это кроссплатформенный фреймворк с открытым исходным кодом для разработки нативных мобильных и настольных приложений на JavaScript и TypeScript, созданный Facebook, Inc\. React Native поддерживает такие платформы как Android, iOS, Web, Windows, позволяя разработчикам использовать возможности библиотеки React вне браузера для создания нативных приложений, имеющих полный доступ к системным API платформ\.

\2) Ionic — это кроссплатформенный фреймворк с открытым исходным кодом\. Этот SDK бесплатен для разработки мобильных приложений для различных платформ, таких как Android, Windows и iOS\. Ionic имеет кроссплатформенные возможности, что означает, что одна и та же кодовая база может использоваться для создания приложения для разных платформ\.

Используя Ionic, становится проще разрабатывать гибридные приложения для мобильных телефонов. Используя различные веб-инструменты и языки, такие как Angular, Typescript, CSS, JavaScript и HTML, можно создавать мобильные приложения для разных платформ.

Кроме того, в Ionic есть хорошая библиотека, в которой можно использовать функциональные компоненты и добавлять их в приложение. Ionic обещает минимальный уровень манипуляций с DOM без снижения уровня производительности.

\3) NativeScript — фреймворк с открытым исходным кодом, разрабатываемый компанией Telerik, для разработки приложений на платформах Android и iOS\. Приложения NativeScript разрабатываются на платформонезависимых языках, таких как Javascript или TypeScript\. В NativeScript реализована полная поддержка фреймворка Angular\. Мобильные приложения, построенные с NativeScript, имеют полный доступ к API платформы так, будто они были разработаны в XCode или в Android Studio\. Также разработчики могут включать в свои приложения сторонние библиотеки с таких ресурсов, как Cocoapods, Android Arsenal, Maven и npm\.js, без создания дополнительных прослоек\. NativeScript и все плагины к нему устанавливаются с помощью менеджера пакетов npm\.

При помощи Google Trends выведем статистику популярности рассмотренных кроссплатформенных фреймворков (рисунок 4).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.004.png)

Рисунок 4 – Статистика популярности кроссплатформенных фреймворков

Составим сравнительную таблицу гибридных технологий разработки приложений для мобильных устройств (таблица 2).

Таблица 2 — Сравнение гибридных технологий

|Характеристика|React Native|Ionic|NativeScript|
| :- | - | - | - |
|Поддержка IOS|+|+|+|
|Поддержка Android|+|+|+|
|3D Графика|-|-|-|
|MVP|+|+|+|
|Стабильность|+|+|+|
|Виджеты|-|-|-|
|WebView|+|+|+|

Исходя из полученных результатов сравнения, что для поддержки IOS и Android можно выбрать любую из рассмотренных технологий. Также стоит отметить то, что все рассмотренные гибридные технологии стабильны в работе.  Для работы с 3D графикой и виджетами не рекомендуются выбирать не одну из рассмотренных технологий.

## <a name="_toc472981381"></a>1.3. Цели и задачи курсового проекта

Целью курсового проекта является разработка мобильного приложения для ведения заметок, выполняющего следующие функции:

- возможность выбора данных;
- возможность добавления данных;
- возможность управления данными;
- возможность удаления данных.

  Для достижения поставленной цели необходимо решить следующие задачи:

\- провести анализ предметной области;

\- сформулировать требования к разрабатываемому приложению;

\- спроектировать структуру базы данных;

\- разработать алгоритмы функционирования мобильного приложения;

\- осуществить выбор средства разработки и технических средств;

\- разработать мобильное приложение в выбранной среде;

Данная программа предназначена для всех категорий пользователей.

Продукт должен в полной степени обеспечивать потребности рядовых пользователей и при этом не отвлекать бессмысленными опциями.


# <a name="_toc1477070646"></a>2. Проектирование мобильного приложения
## <a name="_toc2097463298"></a>2.1. Обоснование выбора средства разработки

Для разработки мобильного приложения был выбран нативный язык программирования Java.

Java — cтрого типизированный объектно-ориентированный язык программирования общего назначения, разработанный компанией Sun Microsystems. Разработка ведётся сообществом, организованным через Java Community Process; язык и основные реализующие его технологии распространяются по лицензии GPL. Ключевой особенностью языка Java является то, что его код сначала транслируется в специальный байт-код, независимый от платформы. А затем этот байт-код выполняется виртуальной машиной JVM (Java Virtual Machine). В этом плане Java отличается от стандартных интерпретируемых языков как PHP или Perl, код которых сразу же выполняется интерпретатором.

В качестве среды разработки была выбрана Android Studio, cреда разработки Android Studio ориентирована на разработку приложений именно под ОС Android.

Android Studio — интегрированная среда разработки производства Google, с помощью которой разработчикам становятся доступны инструменты для создания приложений на платформе Android OS. Android Studio можно установить на Windows, Mac и Linux. Android Studio создавалась на базе IntelliJ IDEA.

IDE можно загрузить и пользоваться бесплатно. В ней присутствуют макеты для создания UI, с чего обычно начинается работа над приложением. В Studio содержатся инструменты для разработки решений для смартфонов и планшетов, а также новые технологические решения для Android TV, Android Wear, Android Auto, Glass и дополнительные контекстуальные модули.

Среда Android Studio предназначена как для небольших команд разработчиков мобильных приложений (даже в количестве одного человека), или же крупных международных организаций с GIT или другими подобными системами управления версиями. Опытные разработчики смогут выбрать инструменты, которые больше подходят для масштабных проектов. Решения для Android разрабатываются в Android Studio с использованием Java или C++. В основе рабочего процесса Android Studio заложен концепт непрерывной интеграции, позволяющий сразу же обнаруживать имеющиеся проблемы. Продолжительная проверка кода обеспечивает возможность эффективной обратной связи с разработчиками. Такая опция позволяет быстрее опубликовать версию мобильного приложения в Google Play App Store. Для этого присутствует также поддержка инструментов LINT, Pro-Guard и App Signing.

С помощью средств оценки производительности определяется состояние файла с пакетом прикладных программ. Визуализация графики дает возможность узнать, соответствует ли приложение ориентиру Google в 16 миллисекунд. С помощью инструмента для визуализации памяти разработчик узнает, когда его приложение будет использовать слишком много оперативной памяти и когда произойдет «сборка мусора». Инструменты для анализа батареи показывают, какая нагрузка приходится на устройство.

Android Studio совместима с платформой Google App Engine для быстрой интеграции в облаке новых API и функций. В среде разработки вы найдете различные API, такие как Google Play, Android Pay и Health. Присутствует поддержка всех платформ Android, начиная с Android 1.6. Есть варианты Android, которые существенно отличаются от версии Google Android. Самая популярная из них — это Amazon Fire OS. В Android Studio можно создавать APK для этой ОС. Поддержка Android Studio ограничивается онлайн-форумами [4].

## <a name="_toc61011757"></a>2.2. Проектирование приложения

Для наглядного понимания функционала приложения строится диаграмма вариантов использования, которая описывает взаимоотношения и зависимости между группами вариантов использования и действующих лиц, участвующими в процессе.

При построении данной диаграммы учитывается, что действующий лицом (актером) является пользователь приложения, который имеет следующие возможные действия:

- Добавление заметок;
- Выбор нужной заметки;
- Изменение заметки;
- Удаление заметки;
- Закрепление/Открепление заметки;
- Поиск заметок;

Построенная диаграмма продемонстрирована на рисунке 5.

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.005.png)

Рисунок 5 – Диаграмма вариантов использования

Для формирования структуры мобильного приложения составляется диаграмма классов.

Описание классов:

1\. MainActivity: Основной класс, создающий заметки.

2\. NotesListAdapter: Адаптер, который предоставляет методы для создания, удаления, сохранения, закрепления, открепления, поиска заметок.

3\. NotesTakerActivity: Класс, служащий для представления заметок.

4\. RoomDB: Класс, отвечающий за подключение к базе данных, выполнение SQL-запросов и управление соединением с базой данных.

Диаграмма классов представлена на рисунке 6.

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.006.png)

Рисунок 6 - Диаграмма классов


## <a name="_toc1923979928"></a>2.3. Структура мобильного приложения

Для наглядного представления работы мобильного приложения, была построена модульная структура функционирования приложения (рисунок 7), который состоит из следующих модулей:

- модуль графического взаимодействия с пользователем: макеты страниц (в данном случае XML), классы Activity для обработки представлений;
- адаптеры: связующий между набором данных и объектами, которые используют эти данные;
- сущности данных: представления данных в виде сущностей.

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.007.png)

Рисунок 7 – Модульная структура приложения

Для понимания последовательности работы мобильного приложения, необходимо отобразить выполнение функционала и условия их выполнения в схеме алгоритма приложения (рисунок 8).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.008.png)

Рисунок 8 – Схема алгоритма работы приложения

Макеты в приложении основы на Empty Activity. Графический интерфейс реализовывается с помощью XML-формата (рисунок 9).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.009.png)

Рисунок 9 – XML-формат реализации графического интерфейса

Для запуска проекта используется автономное мобильное устройство (TECNO LG7n), подключаемое к проекту по средствам USB.

## <a name="_toc1286155211"></a>3.2. Работа приложения

Запускаем приложение (рисунок 10).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.010.png)

Рисунок 10 – Иконка приложения

После запуска приложения нас приветствует стартовое окно (рисунок 11).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.011.png)

Рисунок 11 – Стартовое окно

Нажимаем на кнопку “добавить” в правом нижнем углу. Пишем тему и текст заметки. Если что-то не дописать то высвечивается сообщение об ошибке (рисунок 12).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.012.png)

Рисунок 12 – Добавление заметки

Написали тему и текст сообщения (рисунок 13).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.013.png)

Рисунок 13 – Создание заметки

Нажали на кнопку “Сохранить” в правом верхнем углу (рисунок 14).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.014.png)

Рисунок 14 – Стартовое окно

Делаем долгое нажатие на заметку и выбираем “Закрепить” (рисунок 15).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.015.png)

Рисунок 15 – Закрепление заметки

Закрепили заметку, затем открепим ее (рисунки 16, 17).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.016.png)

Рисунок 16 – Закрепленная заметка

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.017.png)

Рисунок 17 – Открепленная заметка

Добавляем еще заметки (рисунок 18).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.018.png)

Рисунок 18 – Добавленные заметки

Производим поиск заметок по тексту (рисунок 19).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.019.png)

Рисунок 19 – Поиск заметок

Произвели долгое нажатие на заметку и нажали “Удалить” (рисунок 20).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.020.png)

Рисунок 20 – Удаление заметки

Удалили заметку (рисунок 21).

![](Aspose.Words.71f61217-e272-4374-9cb5-67ee97e068f5.021.png)

Рисунок 21 – Удаленная заметка 

Таким образом был создан понятный и простой для использования интерфейс программы.




ЗАКЛЮЧЕНИЕ

Результатом выполнения этой курсовой работы стало разработанное приложение «Заметки». Она написана на высокоуровневом языке программирования – Java, используя среду разработки программного обеспечения Android Studio.  Программа имеет простой и понятный интерфейс, легка в использовании. Она объединяет в себе простоту, доступность и большой набор различных возможностей и не требует от пользователя глубоких знаний работы с телефоном.

При решении поставленных задач были выполнены следующие действия:

- Проанализирована предметная область;
- Выбран метод решения поставленной задачи;
- Описаны основные требования к системе;
- Разработаны соответствующие диаграммы и модели, необходимые для наглядности демонстрации всех процессов;
- Составлен алгоритм решения задачи;
- Реализовать диалог с пользователем, по средствам выбора пользователем нужных ему действий;
- Произведена отладка программы и написана сопроводительная документация.

  Таким образом было реализовано простое в эксплуатации и администрировании приложение “Заметки”.



## <a name="_toc1312793178"></a>СПИСОК ЛИТЕРАТУРЫ
1\. Методические рекомендации Министерства образования и науки РФ от 20 июля 2015 г. № 06-846 [Электронный ресурс] / <https://www.garant.ru/> – информационно-правовой портал / <https://www.garant.ru/products/ipo/prime/doc/71076382/> – рекомендации по организации учебного процесса [Дата обращения: 26.02.2021].

2\. Озерникова Т. Г., Пензина О. Н. О применении профессиональных стандартов при проектировании образовательных программ в вузе // Baikal Research Journal. – 2018. – Т. 9. – №. 1.

3\. Федотенков А. Д. Разработка модуля планирования нагрузки по кафедре: дис. – Южно-Уральский государственный университет. – 2016.

4\. Вьюненко Л. Ф., Михайлов М. В., Первозванская Т. Н. Имитационное моделирование. – 2017.

5\. Ильин В. Моделирование бизнес-процессов. Практический опыт разработчика. – Litres, 2019.

6\. Герасимов К. Б. Влияние развития бизнес-процессов на организационное поведение //Вестник НГИЭИ. – 2019. – №. 8 (99).

7\. Moreno M. et al. Re-distributed manufacturing to achieve a Circular Economy: A case study utilizing IDEF0 modeling //Procedia CIRP. – 2017. – Т. 63. – С. 686-691.

8\. Белоусов А. В., Толкачева О. С., Баева В. Г. Разработка концептуальной модели базы данных информационно-справочных СППР // Системный анализ в проектировании и управлении. – 2017. – С. 297-301.



## <a name="_toc718956430"></a>ПРИЛОЖЕНИЕ А
Листинг программы

**Class NotesListAdapter:**

package com.example.zametki.Adapter;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.cardview.widget.CardView;
import androidx.recyclerview.widget.RecyclerView;

import com.example.zametki.Models.Notes;
import com.example.zametki.NotesClickListener;
import com.example.zametki.R;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class NotesListAdapter extends RecyclerView.Adapter<NotesViewHolder> {

`    `Context context;
`    `List<Notes> list;

`    `NotesClickListener listener;

`    `public NotesListAdapter(Context context, List<Notes> list, NotesClickListener listener) {
`        `this.context = context;
`        `this.list = list;
`        `this.listener = listener;
`    `}

`    `@NonNull
`    `@Override
`    `public NotesViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
`        `return new NotesViewHolder(LayoutInflater.*from*(context).inflate(R.layout.*notes\_list*, parent, false));
`    `}

`    `@Override
`    `public void onBindViewHolder(@NonNull NotesViewHolder holder, int position) {

`        `holder.textView\_title.setText(list.get(position).getTitle());
`        `holder.textView\_title.setSelected(true);

`        `holder.textView\_notes.setText(list.get(position).getNotes());

`        `holder.textView\_date.setText(list.get(position).getDate());
`        `holder.textView\_date.setSelected(true);

`        `if (list.get(position).isPinned()) {
`            `holder.imageView\_pin.setImageResource(R.drawable.*pin\_icon*);
`        `} else {
`            `holder.imageView\_pin.setImageResource(0);
`        `}

`        `int color\_code = getRandomColor();
`        `holder.notes\_conteiner.setCardBackgroundColor(holder.itemView.getResources().getColor(color\_code, null));

`        `holder.notes\_conteiner.setOnClickListener(new View.OnClickListener() {
`            `@Override
`            `public void onClick(View v) {
`                `listener.onClick(list.get(holder.getAdapterPosition()));
`            `}
`        `});
`        `holder.notes\_conteiner.setOnLongClickListener(new View.OnLongClickListener() {
`            `@Override
`            `public boolean onLongClick(View v) {
`                `listener.onLongClick(list.get(holder.getAdapterPosition()), holder.notes\_conteiner);
`                `return true;
`            `}
`        `});
`    `}

`    `private int getRandomColor(){
`        `List <Integer> colorCode = new ArrayList<>();
`        `colorCode.add(R.color.*color1*);
`        `colorCode.add(R.color.*color2*);
`        `colorCode.add(R.color.*color3*);
`        `colorCode.add(R.color.*color4*);
`        `colorCode.add(R.color.*grey*);

`        `Random random = new Random();
`        `int random\_color = random.nextInt(colorCode.size());
`        `return colorCode.get(random\_color);
`    `}

`    `@Override
`    `public int getItemCount() {
`        `return list.size();
`    `}

`    `public void filterList(List<Notes> filteredList) {
`        `list = filteredList;
`        `notifyDataSetChanged();
`    `}
}

class NotesViewHolder extends RecyclerView.ViewHolder {

`    `CardView notes\_conteiner;
`    `TextView textView\_title, textView\_notes, textView\_date;
`    `ImageView imageView\_pin;



`    `public NotesViewHolder(@NonNull View itemView) {
`        `super(itemView);

`        `notes\_conteiner = itemView.findViewById(R.id.*notes\_conteiner*);
`        `textView\_title = itemView.findViewById(R.id.*textView\_title*);
`        `textView\_notes = itemView.findViewById(R.id.*textView\_notes*);
`        `textView\_date = itemView.findViewById(R.id.*textView\_date*);
`        `imageView\_pin = itemView.findViewById(R.id.*imageView\_pin*);


`    `}

}

**Interface MainDAO:**

package com.example.zametki.DataBase;

import static androidx.room.OnConflictStrategy.*REPLACE*;

import androidx.room.Dao;
import androidx.room.Delete;
import androidx.room.Insert;
import androidx.room.Query;

import com.example.zametki.Models.Notes;

import java.util.List;

@Dao
public interface mainDAO {
`    `@Insert(onConflict = *REPLACE*)
`  `void insert (Notes notes);

`    `@Query("SELECT \* FROM notes ORDER BY id DESC")
`    `List<Notes> getAll();

`    `@Query("UPDATE notes SET title =:title, notes = :notes WHERE ID = :id")
`    `void update (int id, String title, String notes);

@Delete
`  `void delete (Notes notes);

@Query("UPDATE notes set pinned = :pin WHERE ID = :id")
void pin(int id, boolean pin);

}

**Class RoomDB:**

package com.example.zametki.DataBase;

import android.content.Context;

import androidx.room.Database;
import androidx.room.Room;
import androidx.room.RoomDatabase;

import com.example.zametki.Models.Notes;

@Database (entities = Notes.class, version = 1, exportSchema = false)
public abstract class RoomDB extends RoomDatabase {

`    `private static RoomDB *database*;
`    `private static String *DATABASE\_NAME* = "NoteApp";

`    `public synchronized static RoomDB getInstance(Context context){
`        `if (*database* == null){
`            `*database* = Room.*databaseBuilder*(context.getApplicationContext(), RoomDB.class, *DATABASE\_NAME*)
.allowMainThreadQueries()
.fallbackToDestructiveMigration()
.build();
`        `}
`        `return *database*;
`    `}
`    `public abstract mainDAO mainDao();


}

**Class Notes:**

package com.example.zametki.Models;

import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.PrimaryKey;

import java.io.Serializable;

@Entity(tableName = "notes")
public class Notes implements Serializable {

`    `@PrimaryKey(autoGenerate = true)
`    `int ID = 0;

`    `@ColumnInfo(name = "title")
`    `String title = "";

`    `@ColumnInfo(name = "notes")
`    `String notes = "";

`    `@ColumnInfo(name = "date")
`    `String date = "";

`    `@ColumnInfo(name = "pinned")
`    `boolean pinned = false;

`    `public int getID() {
`        `return ID;
`    `}

`    `public void setID(int ID) {
`        `this.ID = ID;
`    `}

`    `public String getTitle() {
`        `return title;
`    `}

`    `public void setTitle(String title) {
`        `this.title = title;
`    `}

`    `public String getNotes() {
`        `return notes;
`    `}

`    `public void setNotes(String notes) {
`        `this.notes = notes;
`    `}

`    `public String getDate() {
`        `return date;
`    `}

`    `public void setDate(String date) {
`        `this.date = date;
`    `}

`    `public boolean isPinned() {
`        `return pinned;
`    `}

`    `public void setPinned(boolean pinned) {
`        `this.pinned = pinned;
`    `}
}

**Class MainActivity:**

package com.example.zametki;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.PopupMenu;
import androidx.appcompat.widget.SearchView;
import androidx.cardview.widget.CardView;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.recyclerview.widget.StaggeredGridLayoutManager;

import com.example.zametki.Adapter.NotesListAdapter;
import com.example.zametki.DataBase.RoomDB;
import com.example.zametki.Models.Notes;
import com.example.zametki.databinding.ActivityMainBinding;
import com.google.android.material.floatingactionbutton.FloatingActionButton;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

public class MainActivity extends AppCompatActivity implements PopupMenu.OnMenuItemClickListener {
`    `RecyclerView recyclerView;
`    `FloatingActionButton fab\_add;
`    `NotesListAdapter notesListAdapter;
`    `RoomDB database;
`    `List<Notes> notes = new ArrayList<>();
`    `Notes selectedNote;

`    `SearchView searchView\_home;

`    `private ActivityMainBinding binding;

`    `@Override
`    `protected void onCreate(Bundle savedInstanceState) {
`        `super.onCreate(savedInstanceState);
`        `setContentView(R.layout.*activity\_main*);
`        `//binding = ActivityMainBinding.inflate(getLayoutInflater());
`        `//setContentView(binding.getRoot());

`        `recyclerView = findViewById(R.id.*recycler\_home*);
`        `fab\_add = findViewById(R.id.*fab\_add*);

`        `searchView\_home = findViewById(R.id.*searchView\_home*);

`        `database = RoomDB.*getInstance*(this);
`        `notes = database.mainDao().getAll();

`        `updateRecycler(notes);


`        `fab\_add.setOnClickListener(new View.OnClickListener() {
`            `@Override
`            `public void onClick(View v) {
`                `Intent intent = new Intent(MainActivity.this, NotesTakerActivity.class);
`                `startActivityForResult(intent, 101);

`            `}
`        `});

`        `searchView\_home.setOnQueryTextListener(new SearchView.OnQueryTextListener() {
`            `@Override
`            `public boolean onQueryTextSubmit(String query) {
`                `return false;
`            `}

`            `@Override
`            `public boolean onQueryTextChange(String newText) {
`                `filter(newText);
`                `return true;
`            `}
`        `});
`    `}

`    `private void filter(String newText){
`        `List<Notes> filteredList = new ArrayList<>();
`        `for(Notes singleNote : notes) {
`            `if(singleNote.getTitle().toLowerCase().contains(newText.toLowerCase())
`            `||singleNote.getNotes().toLowerCase().contains(newText.toLowerCase())){
`                `filteredList.add(singleNote);
`            `}
`        `}
`        `notesListAdapter.filterList(filteredList);
`    `}

`    `@Override
`    `protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
`        `super.onActivityResult(requestCode, resultCode, data);

`        `if(requestCode == 101){
`            `if(resultCode == Activity.RESULT\_OK){
`                `assert data != null;
`                `Notes new\_notes = (Notes) data.getSerializableExtra("note");
`                `if (new\_notes != null) {
`                    `database.mainDao().insert(new\_notes);
`                    `notes.clear();
`                    `notes.addAll(database.mainDao().getAll());
`                    `notesListAdapter.notifyDataSetChanged();
`                `}

`            `}
`        `}

`        `if(requestCode == 102){
`            `if(resultCode == Activity.RESULT\_OK){
`                `Notes new\_notes = (Notes) data.getSerializableExtra("note");
`                `if (new\_notes != null) {
`                    `database.mainDao().update(new\_notes.getID(), new\_notes.getTitle(), new\_notes.getNotes());
`                    `notes.clear();
`                    `notes.addAll(database.mainDao().getAll());
`                    `notesListAdapter.notifyDataSetChanged();
`                `}
`            `}
`        `}
`    `}

`    `private void updateRecycler(List<Notes> notes) {

`        `recyclerView.setHasFixedSize(true);
`        `recyclerView.setLayoutManager(new StaggeredGridLayoutManager(2, LinearLayoutManager.VERTICAL));
`        `notesListAdapter = new NotesListAdapter(MainActivity.this, notes, notesClickListener);
`        `recyclerView.setAdapter(notesListAdapter);
`    `}

`    `private final NotesClickListener notesClickListener = new NotesClickListener() {
`        `@Override
`        `public void onClick(Notes notes) {
`        `Intent intent = new Intent(MainActivity.this, NotesTakerActivity.class);
`        `intent.putExtra("old\_note", notes);
`        `startActivityForResult(intent, 102);

`        `}

`        `@Override
`        `public void onLongClick(Notes notes, CardView cardView) {
`            `selectedNote = new Notes();
`            `selectedNote = notes;
`            `showPopup(cardView);


`        `}
`    `};

`    `private void showPopup(CardView cardView) {
`        `PopupMenu popupMenu = new PopupMenu(this, cardView);
`        `popupMenu.setOnMenuItemClickListener(this);
`        `popupMenu.inflate(R.menu.*popup\_menu*);
`        `popupMenu.show();
`    `}


`    `@Override
`    `public boolean onMenuItemClick(MenuItem item) {
`        `if(item.getItemId() == R.id.*pin*) {
`            `if(selectedNote.isPinned()) {
`                `database.mainDao().pin(selectedNote.getID(), false);
`                `Toast.*makeText*(MainActivity.this, "Откреплено", Toast.*LENGTH\_SHORT*).show();
`            `} else {
`                `database.mainDao().pin(selectedNote.getID(), true);
`                `Toast.*makeText*(MainActivity.this, "Закреплено", Toast.*LENGTH\_SHORT*).show();
`            `}
`            `notes.clear();
`            `notes.addAll(database.mainDao().getAll());
`            `notesListAdapter.notifyDataSetChanged();
`            `return true;
`        `} else if(item.getItemId() == R.id.*delete*) {
`            `database.mainDao().delete(selectedNote);
`            `notes.remove(selectedNote);
`            `notesListAdapter.notifyDataSetChanged();
`            `Toast.*makeText*(MainActivity.this, "Удалено", Toast.*LENGTH\_SHORT*).show();
`            `return true;
`        `} else {
`            `return false;
`        `}
`    `}
}

**Class NotesTakerActivity:**

package com.example.zametki;

import androidx.appcompat.app.AppCompatActivity;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.Toast;

import com.example.zametki.Models.Notes;

import java.text.SimpleDateFormat;
import java.util.Date;

public class NotesTakerActivity extends AppCompatActivity {

`    `EditText editText\_title, editText\_notes;
`    `ImageView imageView\_save;
`    `Notes notes;
`    `boolean isOldNote = false;


`    `@Override
`    `protected void onCreate(Bundle savedInstanceState) {
`        `super.onCreate(savedInstanceState);
`        `setContentView(R.layout.*activity\_notes\_taker*);

`        `editText\_title = findViewById(R.id.*editText\_title*);
`        `editText\_notes = findViewById(R.id.*editText\_notes*);

`        `imageView\_save = findViewById(R.id.*imageView\_save*);
`        `notes = new Notes();

`       `try {
`           `notes = (Notes) getIntent().getSerializableExtra("old\_note");
`           `editText\_title.setText(notes.getTitle());
`           `editText\_notes.setText(notes.getNotes());
`           `isOldNote = true;

`       `} catch (Exception e){
`           `e.printStackTrace();
`       `}


`        `imageView\_save.setOnClickListener(new View.OnClickListener() {
`            `@Override
`            `public void onClick(View v) {
`                `String title = editText\_title.getText().toString();
`                `String description = editText\_notes.getText().toString();

`                `if(description.isEmpty()){
`                    `Toast.*makeText*(NotesTakerActivity.this, "Пожалуйста добавьте сообщение", Toast.*LENGTH\_SHORT*).show();
`                    `return;
`                `}
`                `SimpleDateFormat formatter = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss");
`                `Date date = new Date();
`                `if(!isOldNote) {
`                    `notes = new Notes();
`                `}
`                `notes.setTitle(title);
`                `notes.setNotes(description);
`                `notes.setDate(formatter.format(date));

`                `Intent intent = new Intent();
`                `intent.putExtra("note", notes);
`                `setResult(Activity.*RESULT\_OK*, intent);
`                `finish();
`            `}
`        `});
`    `}
}

**Interface NotesClickListener:**

package com.example.zametki;

import androidx.cardview.widget.CardView;

import com.example.zametki.Models.Notes;

public interface NotesClickListener {

`    `void onClick (Notes notes);
`    `void onLongClick(Notes notes, CardView cardView);

}




